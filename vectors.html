<style>
	canvas.vector-demo {
		border-radius: 10px;
		box-shadow: 0px 0px 3px gray;
	}
</style>
<script type="text/javascript">
	function Vector(x, y) {
		this.x = x || 0;
		this.y = y || 0;
	}
	Vector.prototype.perpendicular = function(x) {
		// x can optionally be -1, which returns the reverse of
		// the perpendicular vector. Normally the direction of
		// the normal doesn't matter because you are projecting
		// onto it.
		return new Vector(this.y * (x||1), this.x * (x||1) * -1);
	};
	Vector.prototype.length = function() {
		return Math.sqrt(this.x*this.x + this.y*this.y);
	};
	Vector.prototype.normalized = function() {
		return new Vector(this.x/this.length(), this.y/this.length());
	};
	Vector.prototype.reverse = function() {
		return new Vector(this.x*-1, this.y*-1);
	};

	Vector.prototype.mul = function(n) {
		return new Vector(this.x*n, this.y*n);
	};
	Vector.prototype.add = function(v) {
		return new Vector(this.x + v.x, this.y + v.y);
	};
	Vector.prototype.sub = function(v) {
		return this.add(v.reverse());
	};
	Vector.prototype.div = function(n) {
		return this.mul(1/n);
	};

	Vector.prototype.resize = function(n) {
		return this.normalized().mul(n);
	};
	Vector.prototype.dot = function(v) {
		return this.x * v.x + this.y * v.y;
	};
	Vector.prototype.project = function(v) {
		return v.mul(this.dot(v)/Math.pow(v.length(), 2));
	};
	Vector.prototype.bounce = function(v) {
		return this.add(this.project(v.perpendicular()).reverse().mul(2));
	};
	Vector.prototype.i = function(action, arg) {
		var v = this[action](arg);
		this.x = v.x;
		this.y = v.y;
	};
	Vector.prototype.set = function(v) {
		this.x = v.x;
		this.y = v.y;
	};
	Vector.prototype.toPolar = function() {
		return Math.atan2(this.y, this.x);
	};
	Vector.fromPolar = function(theta, r) {
		var rat = Math.tan(theta);
		var n = new Vector(1, rat).resize(r||1);
		if (Math.abs(theta) >= Math.PI/2) {
			n.ireverse();
		}
		return n;
	};
	Vector.prototype.vectorTo = function(v) {
		return new Vector(v.x-this.x, v.y-this.y);
	};
	Vector.prototype.distanceTo = function(v) {
		return this.vectorTo(v).length();
	};

	Vector.prototype.iadd = function(v) {
		this.set(this.add(v));
	};
	Vector.prototype.isub = function(v) {
		this.set(this.sub(v));
	};
	Vector.prototype.imul = function(v) {
		this.set(this.mul(v));
	};
	Vector.prototype.idiv = function(v) {
		this.set(this.div(v));
	};
	Vector.prototype.iresize = function(n) {
		this.set(this.resize(n));
	};
	Vector.prototype.ireverse = function(v) {
		this.set(this.reverse());
	};
	Vector.prototype.toString = function() {
		return "<" + this.x + ", " + this.y + ">";
	}
	Vector.prototype.render = function(ctx, pos) {
		var nv = this.reverse().toPolar(),
			n1 = Vector.fromPolar(nv + Math.PI/8, 6).add(this).add(pos),
			n2 = Vector.fromPolar(nv - Math.PI/8, 6).add(this).add(pos);

		//ctx.lineWidth = 1;
		ctx.lineCap = "round";
		ctx.lineJoin = "round";
		ctx.beginPath();
		ctx.moveTo(pos.x, pos.y);
		ctx.lineTo(this.x + pos.x, this.y + pos.y);

		ctx.lineTo(n1.x, n1.y);
		ctx.lineTo(n2.x, n2.y);
		ctx.lineTo(this.x + pos.x, this.y + pos.y)

		ctx.stroke();
	}
</script>
<div class="language-javascript">
\[
\newcommand{v}[2]{\left< #1, #2 \right>}
\]

<p class="dropcap">Vectors are math for 3D graphics, physics simulations, raytracers, and anything involving movement. In this article, we'll get started with using vectors to make some pretty graphics with JavaScript.

<h3>Math.</h3>
<p>Vectors are arrows. They have length and direction. They do <em>not</em> have position. (You can play with all the demos below with your mouse.)

<p><canvas class="vector-demo" id="demo-1" width=150 height=150></canvas>

<p>We can represent a vector by the amount it offsets from the origin (if you put the vector's tail on the point ($(0, 0)$), what is the position of the head?). Math people use the following notation for a vector ($v$):

\[\vec{v} = \v{x}{y}\]

<pre><code>function Vector(x, y) {
	this.x = x || 0;
	this.y = y || 0;
}</code></pre>

<p>We can do math with vectors! The easiest operation is vector addition:
\[
\vec{v} + \vec{w} = \v{a}{b} + \v{c}{d} = \v{a+c}{b+d}
\]

<pre><code>Vector.prototype.add = function(v) {
	return new Vector(this.x + v.x, this.y + v.y);
};</code></pre>
This makes a lot more sense visually: to add two vectors, place one vector's tail on the other vector's head to get their sum. It's a simple translation. In the demo below, we add the red and blue vectors to get the green one.

<p><canvas class="vector-demo" id="demo-2" width=150 height=150></canvas>

<p>What good is this? Well, a common use is using vectors in physics. To represent some object, we can use 2 vectors: a <em>position</em> vector for its position and a <em>velocity</em> vector for its speed and direction. In each frame, we can add the velocity vector to the position vector, which <em>translates</em> the object.

<p>We can negate a vector ($\vec{v}$) to ($-\vec{v}$) by reversing its direction, and then subtract a vector by adding its negation (reverse): ($\vec{v} - \vec{w} = \vec{v} + (-\vec{w}) $) In the demo, the gray vector is the negation of the blue one, and the green vector is red minus blue.

<p><canvas class="vector-demo" id="demo-3" width=150 height=150></canvas>

<pre><code>Vector.prototype.reverse = function() {
	return new Vector(this.x*-1, this.y*-1);
};

Vector.prototype.sub = function(v) {
	return this.add(v.reverse());
};</code></pre>

<p>We said we could define a vector with a length and direction. We find the length of a vector with the Pythagorean theorem: ($\left|\v{x}{y}\right| = \sqrt{x^2 + y^2}$). With this definition, we define multiplication of a vector and a scalar (normal number) as creating a vector with the same direction, but a multiplied length. So, trivially, we multiply a vector by a number by multiplying its components: ($\v{x}{y}\times a = \v{ax}{ay}$). Division is just multiplying by the reciprocal of the scalar.

<p>If we divide a vector by its length, we get a vector with length 1.

\[ \hat{v} = \frac{\vec{v}}{\left|\vec{v}\right|} \]

<p>This is called a unit vector, denoted by the pointy hat, and finding a unit vector is called normalizing it. We can resize a vector to whatever length we want by multiplying its unit vector.

<pre><code>Vector.prototype.length = function() {
	return Math.sqrt(this.x*this.x + this.y*this.y);
};
Vector.prototype.mul = function(n) {
	return new Vector(this.x*n, this.y*n);
};
Vector.prototype.div = function(n) {
	return this.mul(1/n);
};
Vector.prototype.normalized = function() {
	return new Vector(this.x/this.length(), this.y/this.length());
};
Vector.prototype.resize = function(n) {
	return this.normalized().mul(n);
};</code></pre>

<p>The last mathy bit is getting the direction of a vector. This needs some trigonometry: we find the arctangent of the ratio of the components to get the angle: ($\tan^{-1}(\frac{y}{x})$). Unfortunately, this expression always gives us an angle between ($0$) and ($\pi$) radians. To get the correct reflex angle, we use JavaScript's <code>Math.atan2</code> function, which takes both (signed) components and returns an angle. Of course, we can go the other way and use <code>Math.tan(angle)</code> to get the unit vector with an angle. The last demo here shows off how to use this knowledge to rotate a vector:

<p><canvas class="vector-demo" id="demo-4" width=150 height=150></canvas>

<pre><code>Vector.prototype.toPolar = function() {
	return Math.atan2(this.y, this.x);
};
Vector.fromPolar = function(theta, r) {
	var rat = Math.tan(theta);
	var n = new Vector(1, rat).resize(r||1);
	if (Math.abs(theta) >= Math.PI/2) {
		n = n.reverse();
	}
	return n;
};</code></pre>

<h3>Now what?</h3>

</div>
<script type="text/javascript">
window.addEventListener(
	"load",
	function() {
		function getOffset(el) {
			return new Vector(
				el.offsetLeft,
				el.offsetTop
			);
		}
		function raf(f) {
			var r = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(f) {window.setTimeout(f, 1); };
			r(function() {
				f();
				raf(f);
			});
		}
		!function() {
			var el = document.getElementById("demo-1"),
				ctx = el.getContext("2d"),
				mpos = new Vector(0, 0);

			el.addEventListener("mousemove", function(e) {
				mpos = new Vector(e.clientX, e.clientY).add(
					new Vector(
						document.body.scrollLeft,
						document.body.scrollTop
					)
				).sub(getOffset(el));

				ctx.canvas.width = ctx.canvas.width + 0;
				mpos.sub(new Vector(75, 75)).render(ctx, new Vector(75, 75));
			});
		}();

		!function() {
			var el = document.getElementById("demo-2"),
				ctx = el.getContext("2d"),
				mpos = new Vector(0, 0);

			el.addEventListener("mousemove", function(e) {
				mpos = new Vector(e.clientX, e.clientY).add(
					new Vector(
						document.body.scrollLeft,
						document.body.scrollTop
					)
				).sub(getOffset(el));

				ctx.canvas.width = ctx.canvas.width + 0;
				var v = mpos.sub(new Vector(75, 75));
				var w = new Vector(50, 20);
				ctx.strokeStyle = "blue";
				v.render(ctx, new Vector(75, 75));
				ctx.strokeStyle = "red";
				w.render(ctx, v.add(new Vector(75, 75)));
				ctx.lineWidth = 3;
				ctx.strokeStyle = "green";
				v.add(w).render(ctx, new Vector(75, 75));
			});
		}();

		!function() {
			var el = document.getElementById("demo-3"),
				ctx = el.getContext("2d"),
				mpos = new Vector(0, 0);

			el.addEventListener("mousemove", function(e) {
				mpos = new Vector(e.clientX, e.clientY).add(
					new Vector(
						document.body.scrollLeft,
						document.body.scrollTop
					)
				).sub(getOffset(el));

				ctx.canvas.width = ctx.canvas.width + 0;
				var v = mpos.sub(new Vector(75, 75));
				
				var w = new Vector(50, 20);


				ctx.strokeStyle = "blue";

				
				v.render(ctx, new Vector(75, 75));
				ctx.strokeStyle = "gray";
				v.reverse().render(ctx, new Vector(75, 75));

				ctx.strokeStyle = "red";
				w.render(ctx, v.reverse().add(new Vector(75, 75)));
				ctx.lineWidth = 3;
				ctx.strokeStyle = "green";
				w.sub(v).render(ctx, new Vector(75, 75));

				//w.sub(v).render(ctx, v.add(new Vector(75, 75)));
			});
		}();

		!function() {
			var el = document.getElementById("demo-4"),
				ctx = el.getContext("2d"),
				mpos = new Vector(0, 0);

			el.addEventListener("mousemove", function(e) {
				mpos = new Vector(e.clientX, e.clientY).add(
					new Vector(
						document.body.scrollLeft,
						document.body.scrollTop
					)
				).sub(getOffset(el));

				ctx.canvas.width = ctx.canvas.width + 0;
				var v = mpos.sub(new Vector(75, 75));
				var w = Vector.fromPolar(v.toPolar()+Math.PI/3, v.length());

				ctx.strokeStyle = "blue";
				v.render(ctx, new Vector(75, 75));
				ctx.lineWidth = 3;

				ctx.strokeStyle = "green";
				w.render(ctx, new Vector(75, 75));

				ctx.beginPath();
				ctx.arc(75, 75,10, v.toPolar(), w.toPolar(), false);
				ctx.lineWidth = 1;
				ctx.stroke();
			});
		}();
	},
	true
);
</script>